> Requires [WebAssembly](https://webassembly.org/) rust target!
>
> Can be added with `rustup target add wasm32-unknown-unknown`

This example explains how you can use code from the previous ones and extend it with basic [Progressive Web App](https://web.dev/what-are-pwas/) capabilities to make it installable. It's not a common solution so let's go step-by-step about how it works. First, there will be a few additions to the project's manifest:

{Cargo.toml}

To make it work and avoid warnings we'll need a separate shared `lib` file that will be used by server and also compiled into a wasm library. We'll also need some `wasm-bindgen` dependencies which provide macros to easily generate wasm<->js bindings, and the `prest-build` utilities that mostly automate the process outlined below.

Once the build process is started and all the dependencies are resolved cargo automatically detects a `build.rs`, compiles and runs it before the compilation of the lib and bins. This script includes just one function call that only runs in the release mode with default config to avoid slowing down the development. So, to see PWA capabilities in action add the `--release` flag in the cargo command or set the `release_only` field of `PWAOptions` to `false`.

{build.rs}

This function builds the same crate as a library (`shared.rs`) into WASM and finally compiles `serve.rs` to be used in the service worker. It will use the same router generated by the `routes` function as the host but will use it in the `handle_fetch` which processes [fetch events](https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent) to handle requests on the client side.

{shared.rs}

Also, `build_pwa` uses wasm-bindgen on the resulting webassembly, injects SW event listeners into the js bindings, generates `.webmanifest` with PWA metadata and includes the default logo (if no other was provided). All the assets are moved to the special `out_dir` folder deep inside `target` dir that cargo creates for the build artifacts.

At this point `build.rs` is done and compilation proceeds to the `serve.rs` binary which will include the same shared service, embedded PWA build outputs and server startup just like the usual host. 

{serve.rs}

That's it! `Head`, `Scripts`, `build_pwa` and other utils are already adding everything necessary with default configs to get started.

Note that some endpoints and handlers, like `.post(submit)` from the hello-html example, likely shouldn't be built into the sw. You can easily share common templates, but when user submits some data or fetches something from the database you'll likely need to process these requests on the host. So, keep routes and handlers that don't need host capabilities like static html in the shared lib and it's modules, and use it as the base for the host-specific. 

For a bit more complex example check out the source code of the blog - it's based on this example's structure and pretty small so should be relatively simple to follow. Mostly it just adds a bit of naive markdown/string processing to this example to render prest's readmes with a simple pretty UI.