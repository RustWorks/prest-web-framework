> Requires [WebAssembly](https://webassembly.org/) rust target!
>
> Can be added with `rustup target add wasm32-unknown-unknown`

This examples extends previous ones with basic [Progressive Web App](https://web.dev/what-are-pwas/) capabilities and becomes installable. How it works step-by-step:

Once the build process is started and all the dependencies are resolved cargo automatically detects a `build.rs`, compiles and runs it before the compilation of the lib and bins. This script includes just one function call that only runs in the release mode with default config to avoid slowing down the development. So, to see it in action add the `--release` flag in the cargo command or set the `release_only` field of `PWAOptions` to `false`.

{build.rs}

This function builds the same crate as a library (`shared.rs`) into WASM and finally compiles `serve.rs` to be used in the service worker. It will use the same router generated by the `routes` function as the host but will use it in the `handle_fetch` which processes [fetch events](https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent) to handle requests on the client side.

{shared.rs}

Also, `build_pwa` uses wasm-bindgen on the resulting webassembly, injects SW event listeners into the js bindings, generates `.webmanifest` with PWA metadata and includes the default logo (if no other was provided). All the assets are moved to the special `out_dir` folder deep inside `target` dir that cargo creates for the build artifacts.

At this point `build.rs` is done and compilation proceeds to the `serve.rs` binary which will include the same shared service, embedded PWA build outputs and server startup just like the usual host. 

{serve.rs}

That's it! `Head`, `Scripts`, `build_pwa` and other utils are already adding everything necessary with default configs to get started.

For a bit more complex example check out the source of the blog - it's based on this example's structure and pretty small so should be relatively simple to follow.