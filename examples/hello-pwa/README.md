Requires [WebAssembly](https://webassembly.org/) target (`rustup target add wasm32-unknown-unknown`)

This examples extends previous ones with [Progressive Web App](https://web.dev/what-are-pwas/). How it works step-by-step:
1. When you invoke `cargo run -p hello-pwa` it checks out the `Cargo.toml` manifest for general information about the crate, it's dependencies, available features etc. By default it uses the `host` feature which includes the `tokio` runtime and some prest utils for the server.
2. Once the build process is started and all the dependencies are resolved cargo automatically detects a `build.rs`, compiles and runs it before the compilation of the host itself. Note that this script includes just one function call that runs only with the `host` feature to avoid running it the second time while building the SW.
3. This script invokes a prest utility `build_pwa` that builds the same crate into WASM but with `sw` feature instead of default ones. With this feature it includes a few different dependencies, an empty build script and finally compiles `serve.rs` to be used in the service worker. It will include the `shared` function that composes the shared routes into a service and `handle_fetch` which uses this service on [fetch events](https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent) to handle requests on the client side.
4. Also, `build_pwa` uses wasm-bindgen on the resulting webassembly, injects SW event listeners into the js bindings, generates `.webmanifest` with PWA metadata and includes the required logo. All the assets are moved to the special `out_dir` folder deep inside `target` dir that cargo creates for the build artifacts.
5. At this point `build.rs` is done and compilation proceeds to the `serve.rs` with the `host` feature which will include the same shared service, [macro-generated](https://doc.rust-lang.org/book/ch19-06-macros.html) `Dist` struct that provides an interface to the embedded PWA assets and the tokio-powered `async main` funciton that starts the server using the shared service merged with routes for the distributed wasm, js, css and other files.
6. Now that everything is compiled cargo simply runs the final binary and you can access it at `http://localhost`. The host will serve a page with the default `Head::pwa()` which includes a lil js snippet to register the service worker and browser will download and activate it automatically. After that it will be able to serve this page offline and will prompt the visitor to install it to create a shortcut and run it in a separate window.

This process may seem a bit convoluted and complex, but I've tried to make it as simple as possible while remaining compatible with usual rust tooling without requiring special CLIs or anything like that. Simplification of this process is a major concern to me so I hope to cut it down even further in the future.