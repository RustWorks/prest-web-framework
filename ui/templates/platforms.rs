use crate::external_link::render as link;
pub fn render() -> maud::Markup {
    maud::html!(
        //(back_button("motivations"))
        ."highlight" {    
            p{"Rust supports development for a wide range of targets from a single codebase. Thanks to wasm32-unknown target (aka usual "(link("WASM", "webassembly.org"))") you can compile almost any Rust code to run efficiently in the "b{"browsers"}" while extending rust safety guarantees with wasm sandboxing. And if you don't need the power of rust for some features you can easily switch to TS."}
            p{"On the "b{"server"}" side you can choose between targeting regular platforms like linux to control the system however you like, or going with wasm32-wasi to produce cloud-native containers. "(link("WASI", "wasmbyexample.dev/examples/wasi-introduction/wasi-introduction.all.en-us.html"))" containers are less capable than linux-based ones, but they are extremely small and can "(link("instantiate in microseconds", "bytecodealliance.org/articles/wasmtime-10-performance#fast-instantiation-results"))" making them a perfect fit for serverless and micro/nano services. Docker beta and some k8s flavors already support WASI containers out of the box."}
            p{"On the "b{"desktops"}" you can use the built-in web views and include the host in the binary or just connect to a remote one. There are plenty of other ways to build for desktops in rust, but that's the easiest way to get a pretty UI while also reusing frontend code. Also, windows already supports installable PWAs and macs might get that support too."}
            p{"On the "b{"mobile"}" devices you have 2 ways to enable offline work: using service worker or by connecting to the native APIs like "(link("tauri-mobile", "github.com/tauri-apps/tauri-mobile"))". Neither is perfect, but service worker is already set up in this example and there are plenty of crates with android and ios bindings if you need deeper native integrations with these platforms."}
            p{"In addition to these rust can be compiled for "b{"blockchains"}", "b{"embedded"}" devices, uncommon OSs like "(link("fuchsia", "fuchsia.dev"))" and "(link("redox", "redox-os.org"))", and "(link("many other platforms", "doc.rust-lang.org/stable/rustc/platform-support.html"))". Probably the only language that has wider support is C due to abundance of legacy systems, but rust has similar and sometimes even better support for modern platforms."}
            p{"Among all of them I want to highlight "b{"WASM"}" and "b{"WASI"}" because rust has great ecosystem around them and they are hecking lit - you can compile once and run efficiently anywhere just like java promised in the past but without legal/licensing issues or vendor lock-in. Also, unlike jvm, webassembly was designed with sandboxing in mind so VMs can safely run unknown binaries and they will only have outbound capabilities that were explicitly provided to them. Also, basic wasm runtime can be as small as 200kb so you can easily and safely embed it anywhere, even inside another wasm runtime."}
            p{"If you want to learn more about rust-wasm combo I'd highly recommend starting with the "(link("Rust&WASM working group docs", "rustwasm.github.io/docs.html"))}
        }
        //(back_button("platforms"))
    )
}