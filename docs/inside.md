**prest** is based on **P**rogressive browser features and **REST**ful architecture. Unlike most other web frameworks it achieves offline work by cross-compiling server code into a WebAssembly-based Service Worker to process requests on the client side. With this approach you don't have to write JS or use custom RPC/JSON/GraphQL protocols for client-server comms. Client files are downloaded and updated in the background without blocking UI. The whole architecture is really RESTful and development feels like building a simple server-side app that just returns HTML. But thanks to Rust's WASM ecosystem you get an installable cross-platform app in the end.  

Under the hood it's based on [Axum](https://github.com/tokio-rs/axum) for ergonomic routing on both server and client. It's also based on [http](https://docs.rs/http/latest/http/) and [tower](https://docs.rs/tower/latest/tower/) for compatability with many other crates. It includes a slightly modified forks of [Maud](https://maud.lambda.xyz/) to easily include HTML snippets inside Rust code and [Rust Embed](https://github.com/pyrossh/rust-embed) to easily bundle PWA and other assets with the compiled binary. [Tokio](https://docs.rs/tokio/latest/tokio/) is the only supported async runtime at the moment.

Interactions with Web APIs from Rust code are powered by [wasm-bindgen](https://rustwasm.github.io/wasm-bindgen/), [js-sys](https://rustwasm.github.io/wasm-bindgen/contributing/js-sys/index.html) and [web-sys](https://rustwasm.github.io/wasm-bindgen/contributing/web-sys/index.html). Also, if you want to include custom TypeScript code in the project they can generate TS declarations of the exported Rust types, and prest also includes [SWC](https://swc.rs/) to transpile and bundle that code. It also includes [grass](https://docs.rs/grass/latest/grass/) - speedy SASS -> CSS compiler for your UI needs. Most likely it will include more common web tooling in the future.

### Step by step
Currently `hello-pwa` is the simplest example with PWA capabilities so I want to explain how it works:
1. When you invoke `cargo run -p hello-pwa` it checks out the `Cargo.toml` manifest for general information about the crate, it's dependencies, available features etc. By default it uses the `host` feature which includes the `tokio` runtime and some prest utils for the server.
2. Once the build process is started and all the dependencies are resolved cargo automatically detects a `build.rs`, compiles and runs it before the compilation of the host itself. Note that this script includes just one function call that runs only with the `host` feature to avoid running it the second time while building the SW.
3. This script invokes a prest utility `build_pwa` that builds the same crate into WASM but with `sw` feature instead of default ones. With this feature it includes a few different dependencies, an empty build script and finally compiles `serve.rs` to be used in the service worker. It will include the `shared` function that composes the shared routes into a service and `handle_fetch` which uses this service on [fetch events](https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent) to handle requests on the client side.
4. Also, `build_pwa` uses wasm-bindgen on the resulting webassembly, injects SW event listeners into the js bindings, generates `.webmanifest` with PWA metadata and includes the required logo. All the assets are moved to the special `out_dir` folder deep inside `target` dir that cargo creates for the build artifacts.
5. At this point `build.rs` is done and compilation proceeds to the `serve.rs` with the `host` feature which will include the same shared service, [macro-generated](https://doc.rust-lang.org/book/ch19-06-macros.html) `Dist` struct that provides an interface to the embedded PWA assets and the tokio-powered `async main` funciton that starts the server using the shared service merged with routes for the distributed wasm, js, css and other files.
6. Now that everything is compiled cargo simply runs the final binary and you can access it at `http://localhost`. The host will serve a page with the default `Head::pwa()` which includes a lil js snippet to register the service worker and browser will download and activate it automatically. After that it will be able to serve this page offline and will prompt the visitor to install it to create a shortcut and run it in a separate window.

This process may seem a bit convoluted and complex, but I've tried to make it as simple as possible while remaining compatible with usual rust tooling without requiring special CLIs or anything like that. Simplification of this process is a major concern to me so I hope to cut it down even further in the future.