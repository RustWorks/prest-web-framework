 It's based on web technologies because they're supported on almost all devices and widely known among the developers. It's built in Rust because it provides a nice balance of development experience, performance, safety and platform support. It nicely fits all kinds of server needs, and thanks to the rich [WASM](https://webassembly.org/) support it can also handle UI faster than JavaScript. Just write some HTML and get a cross-platform UI. Add a couple of lines to make it installable, enable offline work and automatic background updates. Solve any tasks like auth, database integrations, loggers, serverless deployments and many others with ease thanks to interactive examples and [rich ecosystem](https://edezhic.medium.com/reliable-software-engineering-with-rust-5bb4553b5d54).

There are already frameworks like Tauri and Dioxus, but I think that [PWA](https://web.dev/what-are-pwas/) capabilities enable a simpler approach. Inspiration came from [this simple PoC](https://github.com/richardanaya/wasm-service) - combination of a [Service Worker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) based on Rust compiled into [WASM](https://webassembly.org/) with [HTMX](https://htmx.org/) library. I want to highlight HTMX and [Hyperscript](https://hyperscript.org/) because they allow solving almost any UI problem without JavaScript, JSON and other common front-end tech. This way we can cross-compile some server rendering code for the Service Worker and get a restful client almost for free. Also, there are plenty of [Web APIs](https://fugu-tracker.web.app/) available through [wasm bindings](https://github.com/rustwasm/wasm-bindgen), [WASI](https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-intro.md) ecosystem to simplify devops and fascilitate serverless, [WebGPU](https://developer.chrome.com/blog/webgpu-io2023/) for cross-platform AI, complex UIs and games, and many other web-related tech being developed for all kinds of use cases.

Not everything is ideal - Rust requires significant onboarding. Such performance and reliability come at the cost of learning how to use them properly. So one of the main goals of prest is to provide a simple default setup that allows devs to start their projects in minutes.

--

**prest** is based on **P**rogressive browser features and **REST**ful architecture. Unlike most other web frameworks it achieves offline work by cross-compiling server code into a WebAssembly-based Service Worker to process requests on the client side. With this approach you don't have to write JS or use custom RPC/JSON/GraphQL protocols for client-server comms. Client files are downloaded and updated in the background without blocking UI. The whole architecture is really RESTful and development feels like building a simple server-side app that just returns HTML. But thanks to Rust's WASM ecosystem you get an installable cross-platform app in the end.  

Under the hood it's based on [Axum](https://github.com/tokio-rs/axum) for ergonomic routing on both server and client. It's also based on [http](https://docs.rs/http/latest/http/) and [tower](https://docs.rs/tower/latest/tower/) for compatability with many other crates. It includes a slightly modified forks of [Maud](https://maud.lambda.xyz/) to easily include HTML snippets inside Rust code and [Rust Embed](https://github.com/pyrossh/rust-embed) to easily bundle PWA and other assets with the compiled binary. [Tokio](https://docs.rs/tokio/latest/tokio/) is the only supported async runtime at the moment.

Interactions with Web APIs from Rust code are powered by [wasm-bindgen](https://rustwasm.github.io/wasm-bindgen/), [js-sys](https://rustwasm.github.io/wasm-bindgen/contributing/js-sys/index.html) and [web-sys](https://rustwasm.github.io/wasm-bindgen/contributing/web-sys/index.html). Also, if you want to include custom TypeScript code in the project they can generate TS declarations of the exported Rust types, and prest also includes [SWC](https://swc.rs/) to transpile and bundle that code. It also includes [grass](https://docs.rs/grass/latest/grass/) - speedy SASS -> CSS compiler for your UI needs. Most likely it will include more common web tooling in the future.

